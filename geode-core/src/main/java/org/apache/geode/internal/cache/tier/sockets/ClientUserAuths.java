/*
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional information regarding
 * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License. You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.apache.geode.internal.cache.tier.sockets;

import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ThreadLocalRandom;
import java.util.function.Supplier;

import org.apache.logging.log4j.Logger;
import org.apache.shiro.subject.Subject;

import org.apache.geode.annotations.VisibleForTesting;
import org.apache.geode.internal.security.AuthorizeRequest;
import org.apache.geode.internal.security.AuthorizeRequestPP;
import org.apache.geode.logging.internal.log4j.api.LogService;
import org.apache.geode.security.SecurityManager;

public class ClientUserAuths {
  private static final Logger logger = LogService.getLogger();

  private final ConcurrentMap<Long, Subject> subjects = new ConcurrentHashMap<>();

  public Long putSubject(final Subject subject) {
    return putUniquely(subjects, subject);
  }

  public Subject getSubject(final Long userId) {
    return subjects.get(userId);
  }

  public boolean removeSubject(final Long userId) {
    final Subject subject = subjects.remove(userId);
    if (subject == null) {
      return false;
    }

    logger.debug("Subject of {} removed.", userId);
    subject.logout();
    return true;
  }

  public void cleanup(final boolean fromCacheClientProxy) {
    cleanupDeprecated(fromCacheClientProxy);

    for (final Long subjectId : subjects.keySet()) {
      removeSubject(subjectId);
    }
  }

  /**
   * Put a {@code value} into the {@code map} with a uniquely random long key.
   *
   * @param map to put {@code value} into
   * @param value to put into {@code map}
   * @param <V> type of {@code value}
   * @return unique key generated for this {@code value}
   */
  private static <V> Long putUniquely(final ConcurrentMap<Long, V> map, final V value) {
    return putUniquely(map, () -> ThreadLocalRandom.current().nextLong(), value);
  }

  /**
   * Puts a {@code value} into the {@code map} at a unique key generated by {@code keySource}. The
   * {@code keySource} may be invoked multiple times to produce a unique key.
   *
   * @param map to put {@code value} into
   * @param keySource to get unique key from
   * @param value to put into {@code map}
   * @param <K> type of key
   * @param <V> type of {@code value}
   * @return unique key generated for this {@code value}
   */
  @VisibleForTesting
  static <K, V> K putUniquely(final ConcurrentMap<K, V> map,
      final Supplier<K> keySource, final V value) {
    while (true) {
      final K key = keySource.get();
      if (null == map.putIfAbsent(key, value)) {
        return key;
      }
    }
  }

  @VisibleForTesting
  Collection<Subject> getSubjects() {
    return Collections.unmodifiableCollection(subjects.values());
  }

  /**
   * @deprecated since Geode 1.0, use {@link SecurityManager} instead
   */
  @Deprecated
  private final ConcurrentMap<Long, UserAuthAttributes> uniqueIdVsUserAuth =
      new ConcurrentHashMap<>();

  /**
   * @deprecated since Geode 1.0, use {@link SecurityManager} instead
   */
  @Deprecated
  private final ConcurrentMap<String, UserAuthAttributes> cqNameVsUserAuth =
      new ConcurrentHashMap<>();

  /**
   * @deprecated since Geode 1.0, use {@link SecurityManager} instead
   */
  @Deprecated
  public Long putUserAuth(final UserAuthAttributes userAuthAttr) {
    return putUniquely(uniqueIdVsUserAuth, userAuthAttr);
  }

  /**
   * @deprecated since Geode 1.0, use {@link SecurityManager} instead
   */
  @Deprecated
  public UserAuthAttributes getUserAuthAttributes(final Long userId) {
    return uniqueIdVsUserAuth.get(userId);
  }

  /**
   * @deprecated since Geode 1.0, use {@link SecurityManager} instead
   */
  @Deprecated
  public UserAuthAttributes getUserAuthAttributes(final String cqName) {
    return cqNameVsUserAuth.get(cqName);
  }

  /**
   * @deprecated since Geode 1.0, use {@link SecurityManager} instead
   */
  @Deprecated
  public void setUserAuthAttributesForCq(final String cqName, final Long uniqueId,
      final boolean isDurable) {
    final UserAuthAttributes uaa = uniqueIdVsUserAuth.get(uniqueId);

    if (uaa != null) {
      if (!isDurable) {
        cqNameVsUserAuth.put(cqName, uaa);
      } else {
        final UserAuthAttributes oldUaa = cqNameVsUserAuth.put(cqName, uaa);
        if (oldUaa != null) {
          if (oldUaa != uaa) {
            cleanUserAuth(oldUaa);
            uaa.setDurable();
          }
        } else {
          uaa.setDurable();
        }
      }
    }
  }

  /**
   * @deprecated since Geode 1.0, use {@link SecurityManager} instead
   */
  @Deprecated
  public void removeUserAuthAttributesForCq(final String cqName, final boolean isDurable) {
    final UserAuthAttributes uaa = cqNameVsUserAuth.remove(cqName);
    if (uaa != null && isDurable) {
      uaa.unsetDurable();
    }
  }

  /**
   * @deprecated since Geode 1.0, use {@link SecurityManager} instead
   */
  @Deprecated
  public void removeUserId(final Long userId, final boolean keepAlive) {
    UserAuthAttributes uaa = uniqueIdVsUserAuth.get(userId);
    if (uaa != null && !(uaa.isDurable() && keepAlive)) {
      uaa = uniqueIdVsUserAuth.remove(userId);
      logger.debug("UserAuth of {} removed.", userId);
      if (uaa != null) {
        cleanUserAuth(uaa);
      }
    }
  }

  /**
   * @deprecated since Geode 1.0, use {@link SecurityManager} instead
   */
  @Deprecated
  private void cleanUserAuth(final UserAuthAttributes userAuth) {
    if (userAuth != null) {
      final AuthorizeRequest authReq = userAuth.getAuthzRequest();
      try {
        if (authReq != null) {
          authReq.close();
        }
      } catch (Exception ignored) {
      }
      try {
        final AuthorizeRequestPP postAuthzReq = userAuth.getPostAuthzRequest();
        if (postAuthzReq != null) {
          postAuthzReq.close();
        }
      } catch (Exception ignored) {
      }
    }

  }

  /**
   * @deprecated since Geode 1.0, use {@link SecurityManager} instead
   */
  @Deprecated
  private void cleanupDeprecated(final boolean fromCacheClientProxy) {
    for (UserAuthAttributes userAuth : uniqueIdVsUserAuth.values()) {
      // isDurable is checked for multiuser in CQ
      if (!fromCacheClientProxy && !userAuth.isDurable()) {
        // from serverConnection class
        cleanUserAuth(userAuth);
      } else if (fromCacheClientProxy && userAuth.isDurable()) {
        // from cacheclientProxy class
        cleanUserAuth(userAuth);
      }
    }
  }

  /**
   * @deprecated since Geode 1.0, use {@link SecurityManager} instead
   */
  @Deprecated
  public void fillPreviousCQAuth(ClientUserAuths previousClientUserAuths) {
    for (Map.Entry<String, UserAuthAttributes> ent : previousClientUserAuths.cqNameVsUserAuth
        .entrySet()) {
      final String cqName = ent.getKey();
      final UserAuthAttributes prevUaa = ent.getValue();
      final UserAuthAttributes newUaa = cqNameVsUserAuth.putIfAbsent(cqName, prevUaa);

      if (newUaa != null) {
        previousClientUserAuths.cleanUserAuth(prevUaa);
      }
    }
  }

}
